// 
// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

.source_language = "C" @?

declare __assert_fail(*ptr_elt, *ptr_elt, int, *ptr_elt) : void

define add(var0: int, var1: int) : int {
  local n2: int, n1: int
  #: @[14:0]
      n12 = load &var0 @[14:0]
      store &n1 <- n12 @[14:0]
      n13 = load &var1 @[14:0]
      store &n2 <- n13 @[14:0]
      n22 = load &n1 @[14:34]
      n23 = load &n2 @[14:39]
      ret __sil_plusa_int(n22, n23) @[14:27]
      
} @?

declare bar() : void

define call_add() : int {
  #: @[30:25]
      n61 = add(1, 2) @[30:25]
      jmp 1::ret @[30:25]
      
  #1::ret: @[30:18]
      ret n61 @[30:18]
      
} @?

define call_add1(var0: *int, var1: int) : int {
  local y: int, ptr: *int
  #: @[48:0]
      n103 = load &var0 @[48:0]
      store &ptr <- n103 @[48:0]
      n104 = load &var1 @[48:0]
      store &y <- n104 @[48:0]
      n113 = load &ptr @[48:46]
      n114 = load n113 @[48:45]
      n115 = load &y @[48:51]
      n116 = add(n114, n115) @[48:41]
      jmp 8::ret @[48:41]
      
  #8::ret: @[48:34]
      ret n116 @[48:34]
      
} @?

declare foo() : void

declare free(*ptr_elt) : void

define main() : int {
  local var1: int
  #: @[11:0]
      store &var1 <- 0 @[11:0]
      ret 0 @[11:14]
      
} @?

declare malloc(int) : void

define test() : *int {
  #: @[12:15]
      ret null @[12:15]
      
} @?

define test10() : int {
  local sum: int, i: int
  #: @[69:7]
      store &sum <- 0 @[69:7]
      store &i <- 0 @[70:12]
      jmp 3 @[70:8]
      
  #10: @[70:27]
      n190 = load &i @[70:27]
      store &i <- __sil_plusa_int(n190, 1) @[70:27]
      jmp 3 @[70:3]
      
  #13: @[73:3]
      n195 = load &sum @[73:3]
      if __sil_eq(n195, 3) then jmp 18 else jmp 17 @[73:3]
      
  #17: @[73:3]
      _ = __assert_fail(&::str, &::str::1, 73, &__PRETTY_FUNCTION__::test10) @[73:3]
      jmp __assert_fail::void::ret @[73:3]
      
  #18: @[74:10]
      n204 = load &sum @[74:10]
      ret n204 @[74:3]
      
  #3: @[70:19]
      n180 = load &i @[70:19]
      if __sil_lt(n180, 3) then jmp 6 else jmp 13 @[70:3]
      
  #6: @[71:12]
      n184 = load &i @[71:12]
      n185 = load &sum @[71:9]
      store &sum <- __sil_plusa_int(n185, n184) @[71:9]
      jmp 10 @[72:3]
      
  #__assert_fail::void::ret: @[73:3]
      unreachable @[73:3]
      
} @?

define test11() : void {
  #: @[77:16]
      ret null @[77:16]
      
} @?

define test2() : int {
  local n2: int, n1: int
  #: @[19:10]
      n36 = load &n1 @[19:10]
      n37 = load &n2 @[19:15]
      ret __sil_plusa_int(n36, n37) @[19:3]
      
} @?

define test3(var0: *int) : int {
  local ptr: *int
  #: @[22:0]
      n40 = load &var0 @[22:0]
      store &ptr <- n40 @[22:0]
      n46 = load &ptr @[22:31]
      n47 = load n46 @[22:30]
      ret n47 @[22:23]
      
} @?

define test4() : int {
  #: @[26:22]
      n51 = foo() @[26:22]
      jmp 1::ret @[26:22]
      
  #1::ret: @[26:15]
      ret n51 @[26:15]
      
} @?

define test5() : int {
  #: @[28:22]
      n56 = bar() @[28:22]
      jmp 1::ret @[28:22]
      
  #1::ret: @[28:15]
      ret n56 @[28:15]
      
} @?

define test6() : int {
  local var1: int, ptr: *int
  #: @[33:8]
      store &ptr <- null @[33:8]
      n69 = call_add() @[34:7]
      jmp 3::ret @[34:7]
      
  #3::ret: @[34:7]
      if __sil_eq(n69, 3) then jmp 5 else jmp 8 @[34:7]
      
  #5: @[35:13]
      n73 = load &ptr @[35:13]
      n74 = load n73 @[35:12]
      store &var1 <- n74 @[35:5]
      jmp 9 @[35:5]
      
  #8: @[37:5]
      store &var1 <- 0 @[37:5]
      jmp 9 @[37:5]
      
  #9: @[38:1]
      n81 = load &var1 @[38:1]
      ret n81 @[38:1]
      
} @?

define test7() : int {
  local var1: int, ptr: *int
  #: @[41:8]
      store &ptr <- null @[41:8]
      n89 = call_add() @[42:7]
      jmp 3::ret @[42:7]
      
  #3::ret: @[42:7]
      if __sil_eq(n89, 5) then jmp 5 else jmp 8 @[42:7]
      
  #5: @[43:13]
      n93 = load &ptr @[43:13]
      n94 = load n93 @[43:12]
      store &var1 <- n94 @[43:5]
      jmp 9 @[43:5]
      
  #8: @[45:5]
      store &var1 <- 0 @[45:5]
      jmp 9 @[45:5]
      
  #9: @[46:1]
      n101 = load &var1 @[46:1]
      ret n101 @[46:1]
      
} @?

define test8(var0: *int) : int {
  local var2: int, ret: int, ptr: *int, null_ptr: *int
  #: @[50:0]
      n118 = load &var0 @[50:0]
      store &ptr <- n118 @[50:0]
      n127 = load &ptr @[51:4]
      store n127 <- 1 @[51:8]
      store &null_ptr <- null @[52:8]
      n132 = load &ptr @[53:23]
      n133 = call_add1(n132, 2) @[53:13]
      jmp 8::ret @[53:13]
      
  #11: @[55:13]
      n139 = load &null_ptr @[55:13]
      n140 = load n139 @[55:12]
      store &var2 <- n140 @[55:5]
      jmp 15 @[55:5]
      
  #14: @[57:5]
      store &var2 <- 0 @[57:5]
      jmp 15 @[57:5]
      
  #15: @[58:1]
      n147 = load &var2 @[58:1]
      ret n147 @[58:1]
      
  #8::ret: @[53:7]
      store &ret <- n133 @[53:7]
      n135 = load &ret @[54:7]
      if __sil_eq(n135, 3) then jmp 11 else jmp 14 @[54:7]
      
} @?

define test9() : int {
  local ret: int, ptr: *int
  #: @[61:14]
      n154 = __sil_malloc(<int>) @[61:14]
      store &ptr <- n154 @[61:8]
      n156 = load &ptr @[62:4]
      store n156 <- 42 @[62:8]
      n159 = load &ptr @[63:14]
      n160 = load n159 @[63:13]
      store &ret <- n160 @[63:7]
      n162 = load &ptr @[64:8]
      _ = __sil_free(n162) @[64:3]
      n164 = load &ret @[65:10]
      ret n164 @[65:3]
      
} @?

global ::str: *ptr_elt

global ::str::1: *ptr_elt

global __PRETTY_FUNCTION__::test10: *ptr_elt

